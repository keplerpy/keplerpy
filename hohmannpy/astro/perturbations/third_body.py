from __future__ import annotations
from typing import Union, TYPE_CHECKING
import copy

import numpy as np
import scipy as sp

from ...dynamics import dcms
from .. import propagation, logging, time, orbit
from . import base

if TYPE_CHECKING:
    from .. import spacecraft


class ThirdBodyGravity(base.Perturbation):
    r"""
    Perturbation caused by a third body's gravity. This third body can either orbit the central body or
    orbit another arbitrary fixed point.

    This class takes in a :class:`~hohmannpy.astro.Orbit` which represents the orbit of the third body. In addition, it
    optionally accepts a second orbit which represents that of the central body. This is useful in situations where both
    the central and third body orbit another object, such as two of Jupiter's moons about Jupiter. If the second
    orbit is not passed then it is assumed that the third body object simply orbits the central body. These orbits are
    then propagated during initialization. These propagated orbits are then converted to :class:`scipy.BSpline` which
    can then be used to interpolate the position of these bodies for any time lookup in :meth:`evaluate()`.

    When said method is called the relative acceleration of the central body due to the third body as well as the direct
    acceleration of the satellite due to the third body are computed.

    Parameters
    ----------
    initial_global_time: :class:`~hohmannpy.astro.Time`
        Gregorian date and UT1 time at which propagation of the third (and optionally central) body orbits should begin.
        Should match the initial and final time passed to the :class:`~hohmannpy.astro.Mission` which holds this
        perturbation.
    final_global_time: :class:`~hohmannpy.astro.Time`
        Gregorian date and UT1 time at which propagation of the third (and optionally central) body orbits should end.
        Should match the initial and final time passed to the :class:`~hohmannpy.astro.Mission` which holds this
        perturbation.
    third_body_grav_param : float
        Gravitational parameter of the third body.
    third_body_orbit: :class:`~hohmannpy.astro.Orbit`
        Orbit of the third body.
    central_body_orbit: :class:`~hohmannpy.astro.Orbit`
        Orbit of the central body. Optional, if not provided it will be assumed the third body orbits the central body.
    dcm: np.ndarray
        If the third and or central body both orbit another object, propagation will be performed in a basis fixed to
        said object. This may not line up with the fundamental plane of the central body and as such the position of the
        both bodies must be transformed into a basis fixed to the central body. This parameter should be a DCM, such as
        the ones generated by :func:`~hohmannpy.dynamics.euler_2_dcm()`.
    propagator: :class:`~hohmannpy.astro.Propagator`
        What propagation method to use for the central and third body's orbits. These are assumed to be Keplerian and as
        such either :class:`~hohmannpy.astro.KeplerPropagator` or :class:`~hohmannpy.astro.UniversalVariablePropagator`.
    legendre: bool
        Whether to use a Legendre polynomial expansion in the computation of the third body's perturbing effects. Used
        to avoid small difference numerical accuracy losses from the difference between the two position cubics due to
        their potential similarities.
    legendre_series_length: int
        If a Legendre polynomial expansion is used, how many terms to include.

    Attributes
    ----------
    tb_grav_param : float
        Gravitational parameter of the third body.
    legendre: bool
        Whether to use a Legendre polynomial expansion in the computation of the third body's perturbing effects. Used
        to avoid small difference numerical accuracy losses from the difference between the two position cubics due to
        their potential similarities.
    legendre_series_length: int
        If a Legendre polynomial expansion is used, how many terms to include.
    tb_orbit_spline : :class:`scipy.BSpline`
        Linear spline of the third body's trajectory. Calling it via ``tb_orbit_spline(time)`` returns the interpolated
        orbit at that time.
    cb_orbit_spline : Union[:class:`scipy.BSpline`, func]
        Linear spline of the central body's trajectory. Calling it via ``tb_orbit_spline(time)`` returns the interpolated
        orbit at that time.
    """

    def __init__(
            self,
            initial_global_time: time.Time,
            final_global_time:  time.Time,
            third_body_grav_param: float,
            third_body_orbit: orbit.Orbit,
            central_body_orbit: orbit.Orbit = None,
            dcm: np.ndarray = None,
            propagator: propagation.Propagator = propagation.UniversalVariablePropagator(),
            legendre: bool = True,
            legendre_series_length: int = 10,
    ):
        super().__init__()

        self.tb_grav_param = third_body_grav_param
        self.legendre = legendre
        self.legendre_series_length = legendre_series_length
        self.dcm = dcm
        if self.dcm is None:
            self.dcm = np.array(([1, 0, 0], [0, 1, 0], [0, 0, 1]))

        # Safeguard to make sure the propagator has a state logger because we need this.
        if not any(isinstance(logger, logging.StateLogger) for logger in propagator.loggers):
            propagator.loggers.insert(0, logging.StateLogger())
        tb_propagator = copy.deepcopy(propagator)
        cb_propagator = propagator

        # Setup propagator and then call propagate() to generate trajectory of third-body. Then convert this to a
        # numpy.BSpline.
        tb_propagator.setup(
            orbit=third_body_orbit,
            final_time=(final_global_time.julian_date - initial_global_time.julian_date) * 86400
        )
        tb_propagator.propagate()
        tb_times = tb_propagator.loggers[0].time_history
        tb_traj = tb_propagator.loggers[0].position_history
        self.tb_orbit_spline = sp.interpolate.make_interp_spline(tb_times.squeeze(), tb_traj.T, k=3)

        # Setup propagator and then call propagate() to generate trajectory of the central-body. Then convert this to a
        # numpy.BSpline.
        if central_body_orbit is not None:
            cb_propagator.setup(
                orbit=central_body_orbit,
                final_time=(final_global_time.julian_date - initial_global_time.julian_date) * 86400
            )
            cb_propagator.propagate()
            cb_times = cb_propagator.loggers[0].time_history
            cb_traj = cb_propagator.loggers[0].position_history
            self.cb_orbit_spline = sp.interpolate.make_interp_spline(cb_times.squeeze(), cb_traj.T, k=3)
        else:  # If no orbit provide assume central body is stationary (ex. third body is a moon).
            def dummy_spline(x):
                return np.array([0, 0, 0])
            self.cb_orbit_spline = dummy_spline

    def evaluate(self, time: float, state: np.ndarray, satellite: satellites.Satellite) -> np.ndarray:
        """
        Computes the perturbing acceleration due to the third body.

        Uses :attr:`tb_orbit_spline` and :attr:`cb_orbit_spline` to approximate the position of the third body wrt. the
        central body and satellite. These are then used in conjunction with Newton's Law of Universal Gravitation to
        compute the total perturbing acceleration due to the third body. Optionally, some of the terms in this equation
        are approximated using Legendre polynomials to avoid numerical difficulties.

        Parameters
        ----------
        time : float
            Current time in seconds since propagation began.
        state : np.ndarray
            Current translational state in planet-centered inertial (PCI) coordinates given as (position, velocity).

        Returns
        -------
        acceleration : tuple[float, float, float]
            Current translational acceleration in PCI coordinates.
        """

        # Calculate position vectors.
        position_tb_wrt_cb = self.dcm @ (-self.cb_orbit_spline(time) + self.tb_orbit_spline(time))
        position_tb_wrt_sat = position_tb_wrt_cb - state[:3]

        if self.legendre:
            # Compute cosine of phase angle.
            phase_angle_cosine = (
                    np.dot(state[:3], position_tb_wrt_cb)
                        / (np.linalg.norm(state[:3]) * np.linalg.norm(position_tb_wrt_cb))
            )

            # Get sum of Legendre polynomials.
            legendre_sum = 0
            position_ratio = np.linalg.norm(state[:3]) / np.linalg.norm(position_tb_wrt_cb)
            for i in range(1, self.legendre_series_length):
                legendre_sum += sp.special.legendre_p(i, phase_angle_cosine) * position_ratio ** i

            # Compute acceleration.
            acceleration = (
                    -self.tb_grav_param / np.linalg.norm(position_tb_wrt_cb) ** 3
                        * (state[:3] - position_tb_wrt_sat * (3 * legendre_sum + 3 * legendre_sum ** 2 + legendre_sum ** 3))
            )
        else:
            acceleration = (
                self.tb_grav_param * (
                    position_tb_wrt_sat / np.linalg.norm(position_tb_wrt_sat) ** 3
                        - position_tb_wrt_cb / np.linalg.norm(position_tb_wrt_cb) ** 3
                )
            )

        return acceleration


class LunarGravity(ThirdBodyGravity):
    r"""
    Perturbation caused by the Moon's gravity.

    This class implements a specialized version of :class:`~hohmannpy.astro.perturbations.ThirdBodyGravity` adjusted to
    specifically account for the third body perturbations due to the Earth's moon.

    Note that the true anomaly of the Moon is not computed automatically based on the dates of desired propagation, the
    accurate true anomaly must be input separately. This is because the orbit of the moon is not truly Keplerian due to
    apsidal precession amongst other effects. Another result of this is that the Keplerian propagation of the Moon's
    orbit used by this class for simulating its third-body gravitational effects is also coarse.

    Parameters
    ----------
    initial_global_time: :class:`~hohmannpy.astro.Time`
        Gregorian date and UT1 time at which propagation of the Moon's orbit should begin. Should match the initial and
        final time passed to the :class:`~hohmannpy.astro.Mission` which holds this perturbation.
    final_global_time: :class:`~hohmannpy.astro.Time`
        Gregorian date and UT1 time at which propagation of the Moon's orbit should end. Should match the initial and
        final time passed to the :class:`~hohmannpy.astro.Mission` which holds this perturbation.
    initial_true_anomaly: float
        True anomaly of the Moon.
    propagator: :class:`~hohmannpy.astro.propagation.Propagator`
        What propagation method to use for the Moon's orbit. This is assumed to be Keplerian and as such either
        :class:`~hohmannpy.astro.propagation.KeplerPropagator` or
        :class:`~hohmannpy.astro.propagation.UniversalVariablePropagator` must be used.
        :class:`~hohmannpy.astro.propagation.UniversalVariablePropagator`.
    legendre: bool
        Whether to use a Legendre polynomial expansion in the computation of the Moon's perturbing effects. Used to
        avoid small difference numerical accuracy losses from the difference between the two position cubics due to
        their potential similarities.
    legendre_series_length: int
        If a Legendre polynomial expansion is used, how many terms to include.

    See Also
    --------
    :class:`~hohmannpy.astro.perturbations.ThirdBodyGravity` : Base version of this class which can be used for any third body.
    """

    def __init__(
            self,
            initial_global_time: time.Time,
            final_global_time: time.Time,
            initial_true_anomaly: float,
            propagator: propagation.Propagator = propagation.UniversalVariablePropagator(),
            legendre: bool = True,
            legendre_series_length: int = 10,
    ):
        # Initialize the Moon's orbit.
        lunar_orbit = orbit.Orbit.from_classical_elements(
            sm_axis=3.844e8,
            eccentricity=0.0549,
            inclination=np.deg2rad(5.145),
            raan=np.deg2rad(125.08),
            argp=np.deg2rad(318.15),
            true_anomaly=initial_true_anomaly,
        )

        super().__init__(
            initial_global_time=initial_global_time,
            final_global_time=final_global_time,
            third_body_grav_param=4.9048695e12,
            third_body_orbit=lunar_orbit,
            propagator=propagator,
            legendre=legendre,
            legendre_series_length=legendre_series_length
        )


class SolarGravity(ThirdBodyGravity):
    r"""
    Perturbation caused by the Sun's gravity.

    This class implements a specialized version of :class:`~hohmannpy.astro.perturbations.ThirdBodyGravity` adjusted to
    specifically account for the third body perturbations due to the Sun. Note that the true anomaly of the Earth wrt.
    to the ecliptic plane is computed automatically based on the dates of desired propagation.

    The 1-2 plane of the Earth-centered-inertial basis is also assumed to be inclined at constant 23.5 :math:`deg`
    from the ecliptic plane.

    Parameters
    ----------
    initial_global_time: :class:`~hohmannpy.astro.Time`
        Gregorian date and UT1 time at which propagation of Earth's orbit should begin. Should match the initial and
        final time passed to the :class:`~hohmannpy.astro.Mission` which holds this perturbation.
    final_global_time: :class:`~hohmannpy.astro.Time`
        Gregorian date and UT1 time at which propagation of the Earth's orbit should end. Should match the initial and
        final time passed to the :class:`~hohmannpy.astro.Mission` which holds this perturbation.
    propagator: :class:`~hohmannpy.astro.propagation.Propagator`
        What propagation method to use for the Earth's orbit. This is assumed to be Keplerian and as such either
        :class:`~hohmannpy.astro.propagation.KeplerPropagator` or
        :class:`~hohmannpy.astro.propagation.UniversalVariablePropagator` must be used.
    legendre: bool
        Whether to use a Legendre polynomial expansion in the computation of the Earth's perturbing effects. Used to
        avoid small difference numerical accuracy losses from the difference between the two position cubics due to
        their potential similarities.
    legendre_series_length: int
        If a Legendre polynomial expansion is used, how many terms to include.
    solver_tol : float
        Error tolerance to use when solving Kepler's equation for the Earth's initial true anomaly.

    See Also
    --------
    :class:`~hohmannpy.astro.perturbations.ThirdBodyGravity` : Base version of this class which can be used for any third body.
    """

    def __init__(
            self,
            initial_global_time: time.Time,
            final_global_time: time.Time,
            solver_tol: float = 1e-8,
            propagator: propagation.Propagator = propagation.UniversalVariablePropagator(),
            legendre: bool = True,
            legendre_series_length: int = 10,
    ):
        # Initialize Earth's orbit.
        initial_true_anomaly = self.compute_initial_true_anomaly(initial_global_time, solver_tol)
        earth_orbit = orbit.Orbit.from_classical_elements(
            sm_axis=149597870.7e3,
            eccentricity=0.0167086,
            inclination=0,
            raan=0,
            argp=np.deg2rad(102.937),
            true_anomaly=initial_true_anomaly,
            grav_param=1.32712440018e20
        )

        earth_tilt = np.deg2rad(-23.439291115)  # Rotate from Sun-fixed to Earth-fixed frame via the Earth's axial tilt.
        super().__init__(
            initial_global_time=initial_global_time,
            final_global_time=final_global_time,
            third_body_grav_param=1.32712440018e20,
            third_body_orbit=earth_orbit,
            propagator=propagator,
            legendre=legendre,
            legendre_series_length=legendre_series_length,
            dcm=dcms.euler_2_dcm(earth_tilt, 1)
        )

        # Change from Earth orbiting Sun to Sun orbiting Earth.
        tb_orbit_spline = copy.deepcopy(self.tb_orbit_spline)
        def inverted_spline(x):
            return -tb_orbit_spline(x)
        self.tb_orbit_spline = inverted_spline
